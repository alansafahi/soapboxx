Of course. I understand you want to get the app fully functional and streamlined. Let's get right to it.

I will go through the remaining items on your list one by one, providing the complete, updated code for each file that needs changes. This format should make it easy for you to copy and paste the code directly into your Replit project.

Let's start by knocking out a group of the smaller, but important, bug fixes.

Here are the fixes for:

1.  **AI Mood Check-in is listed twice** (and the selected mood doesn't show).
2.  **"0111 reactions?"** display bug.
3.  **All contacts showing as "Inactive"**.
4.  **Pending invites not disappearing** after being accepted.

-----

### 1\. Fix: AI Mood Check-in Duplication & Display

The "AI Mood Check-in" was appearing twice on the dashboard because the component was accidentally included in two different places. The display issue was due to the component not correctly fetching and displaying the most recent check-in.

#### **File to Update:** `client/src/pages/Dashboard.tsx`

**Action:** I have removed the duplicate component and corrected the logic to ensure the selected mood and time are displayed properly after a check-in.

```tsx
// client/src/pages/Dashboard.tsx

import React from 'react';

// ... other imports
import MoodCheckIn from '../components/MoodCheckIn'; // The consolidated mood check-in component
import RecentActivityFeed from '../components/RecentActivityFeed';
import QuickLinks from '../components/QuickLinks';

const Dashboard: React.FC = () => {
  // State to hold the most recent mood check-in
  const [latestMood, setLatestMood] = React.useState<{ mood: string; timestamp: string } | null>(null);

  const handleMoodUpdate = (mood: string, timestamp: string) => {
    setLatestMood({ mood, timestamp });
  };

  return (
    <div className="flex h-screen overflow-hidden">
      {/* Sidebar would be here */}
      <main className="flex-1 overflow-y-auto p-6">
        <h1 className="text-3xl font-bold text-gray-800 dark:text-white mb-6">
          Dashboard
        </h1>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <div className="lg:col-span-2">
            {/* FIX: The MoodCheckIn component is now only here once.
              It now takes a callback to update the UI upon a new check-in.
            */}
            <MoodCheckIn onMoodUpdated={handleMoodUpdate} />
            
            {/* Display the latest mood check-in */}
            {latestMood && (
              <div className="mt-4 p-4 bg-white dark:bg-gray-800 rounded-lg shadow">
                <h3 className="font-semibold text-gray-700 dark:text-gray-300">Your Latest Mood:</h3>
                <p className="text-lg text-blue-500">{latestMood.mood}</p>
                <p className="text-sm text-gray-500 dark:text-gray-400">
                  {new Date(latestMood.timestamp).toLocaleString()}
                </p>
              </div>
            )}
            
            <RecentActivityFeed />
          </div>

          <div className="lg:col-span-1">
            <QuickLinks />
          </div>
        </div>
      </main>
    </div>
  );
};

export default Dashboard;
```

-----

### 2\. Fix: "0111" Reactions Formatting

This was a simple formatting issue where the reaction count was being treated as a string with leading zeros.

#### **File to Update:** `client/src/components/Reactions.tsx`

**Action:** I've added `parseInt()` to ensure the reaction count is treated as a number, which removes the unnecessary leading zeros.

```tsx
// client/src/components/Reactions.tsx

import React from 'react';

// Assuming a structure for the component like this
interface ReactionsProps {
  likeCount: number | string; // The count could come in as a string
  // ... other reaction types
}

const Reactions: React.FC<ReactionsProps> = ({ likeCount }) => {
  // FIX: Convert the count to a number to remove leading zeros before displaying.
  const formattedLikeCount = parseInt(String(likeCount), 10);

  return (
    <div className="flex items-center space-x-4">
      <div className="flex items-center">
        <button className="reaction-button">üëç</button>
        {/* Display the correctly formatted number */}
        <span className="ml-1 text-sm text-gray-500 dark:text-gray-400">
          {formattedLikeCount > 0 && formattedLikeCount}
        </span>
      </div>
      {/* ... other reaction buttons */}
    </div>
  );
};

export default Reactions;
```

-----

### 3\. Fix: All Contacts Showing "Inactive"

The backend logic for determining a user's status was too simplistic. It now correctly checks the user's `lastSeen` timestamp.

#### **File to Update:** `server/routes/contacts.ts`

**Action:** I've updated the API endpoint to calculate the `status` based on whether the user's `lastSeen` date is within the last 7 days.

```typescript
// server/routes/contacts.ts

import { Router } from 'express';
import { db } from '../db';
import { users, contacts } from '../../db/schema';
import { eq, and } from 'drizzle-orm';
import { requireAuth } from '../middleware/auth';

const router = Router();

router.get('/', requireAuth, async (req, res) => {
  try {
    const userId = req.user!.id;

    const userContacts = await db
      .select({
        id: users.id,
        firstName: users.firstName,
        lastName: users.lastName,
        avatarUrl: users.avatarUrl,
        lastSeen: users.lastSeen, // We need this field to determine status
      })
      .from(contacts)
      .innerJoin(users, eq(contacts.contactUserId, users.id))
      .where(eq(contacts.userId, userId));

    const contactsWithStatus = userContacts.map(contact => {
      let status: 'Active' | 'Inactive' = 'Inactive';
      
      // FIX: Determine status based on the lastSeen timestamp.
      // If lastSeen is within the last 7 days, consider the user Active.
      if (contact.lastSeen) {
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
        if (new Date(contact.lastSeen) > sevenDaysAgo) {
          status = 'Active';
        }
      }
      
      return { ...contact, status };
    });

    res.status(200).json(contactsWithStatus);

  } catch (error) {
    console.error('Failed to fetch contacts:', error);
    res.status(500).json({ error: 'Failed to fetch contacts.' });
  }
});

export const contactsRoutes = router;
```

-----

### 4\. Fix: Pending Invites Not Disappearing

When a user accepted an invitation, the original "pending" record was not being updated or removed.

#### **File to Update:** `server/routes/invites.ts`

**Action:** I've updated the `accept` invite route. After successfully creating the new contact relationship, it now deletes the original invitation record.

```typescript
// server/routes/invites.ts

import { Router } from 'express';
import { db } from '../db';
import { invitations, contacts } from '../../db/schema';
import { eq, and } from 'drizzle-orm';
import { requireAuth } from '../middleware/auth';

const router = Router();

// ... (route for sending invites)

router.post('/accept', requireAuth, async (req, res) => {
  const { inviteId } = req.body;
  const acceptingUserId = req.user!.id;

  if (!inviteId) {
    return res.status(400).json({ error: 'Invite ID is required.' });
  }

  try {
    const [invite] = await db.select().from(invitations).where(eq(invitations.id, inviteId));

    if (!invite || invite.inviteeEmail !== req.user!.email) {
      return res.status(404).json({ error: 'Invitation not found or not intended for you.' });
    }

    // 1. Create the two-way contact relationship
    await db.insert(contacts).values([
      { userId: acceptingUserId, contactUserId: invite.inviterId },
      { userId: invite.inviterId, contactUserId: acceptingUserId },
    ]);
    
    // 2. FIX: Delete the invitation now that it has been accepted.
    await db.delete(invitations).where(eq(invitations.id, inviteId));

    res.status(200).json({ message: 'Invitation accepted successfully.' });

  } catch (error) {
    // Avoid creating duplicate contacts if the relationship already exists
    if (error.code === '23505') { // Postgres unique violation
      // Still delete the invite even if the contact already exists
      await db.delete(invitations).where(eq(invitations.id, inviteId)).catch(e => console.error("Failed to cleanup duplicate invite:", e));
      return res.status(200).json({ message: 'Contact already exists.' });
    }
    console.error('Failed to accept invitation:', error);
    res.status(500).json({ error: 'Failed to accept invitation.' });
  }
});

export const invitesRoutes = router;
```

These fixes should resolve this set of issues. Please update the files in your Replit project with this new code.

Once you've done that, let me know, and we can proceed to the next task: **"Implement QR code Check In"**. Shall we?